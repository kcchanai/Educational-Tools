<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spacecraft Orbit Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #deltaVSlider {
    position: fixed;
    bottom: 10px; /* Position 10px from the bottom */
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    color: white;
    }

    #sliderValue {
        position: fixed;
        bottom: 40px; /* Position below the slider */
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 16px;
    }


    #impulseButton {
            padding: 10px;
            background-color: #007BFF;
            color: white;
            border: none;
            cursor: pointer;
        }

    #impulseButton:hover {
        background-color: #0056b3;
    }

    /* Styling for the reset button */
    #resetButton {
        padding: 12px 20px;
        background-color: #FF5733; /* Red color */
        color: white;
        border: none;
        font-size: 16px;
        cursor: pointer;
    }

    #resetButton:hover {
        background-color: #C70039; /* Darker red on hover */
    }

    /* Container for buttons */
    .button-container {
        position: fixed;
        bottom: 70px; /* Position both buttons above the slider */
        left: 50%;
        transform: translateX(-50%);
        display: flex; /* Align buttons horizontally */
        gap: 10px; /* Add space between buttons */
    }

    /* Optional: Style the buttons */
    button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }
    </style>
</head>
<body>
<canvas id="orbitCanvas"></canvas>

<!-- Slider to control deltaV -->
<div id="deltaVSlider">
    <label for="deltaV">deltaV: </label>
    <input type="range" id="deltaV" min="-1000" max="1000" value="10">
</div>

<div id="sliderValue">deltaV: 10 m/s</div>

<div class="button-container">
    <button id="impulseButton">Apply Impulse</button>
    <button id="resetButton">Reset Simulation</button>
</div>

<script>
    const canvas = document.getElementById('orbitCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to fill the window
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Constants
    const G = 6.67430e-11; // Gravitational constant (m^3⋅kg^−1⋅s^−2)
    const Me = 5.972e24; // Mass of the Earth (kg)
    const Mm = 7.348e22 * 40e-22; // Mass of the Moon (kg)
    const EARTH_RADIUS = 6371000; // Earth's radius in meters
    const MOON_DISTANCE = 3.844e8 * 1e-6; // Average distance from Earth to Moon in meters

    let deltaV = 10; // Impulsive change in velocity (m/s) - set initial value

    let ax_earth = 0;
    let ay_earth = 0;
    let ax_moon = 0;
    let ay_moon = 0;

    // Initial conditions for the spacecraft (Low Earth Orbit)
    const altitude = 500000; // altitude (meters)
    let r = EARTH_RADIUS + altitude; // Initial distance from the center of the Earth (meters)
    
    // Calculate the initial tangential velocity for circular orbit at LEO
    let v = -Math.sqrt(G * Me / r); // Orbital velocity in m/s
    
    // Initial angle and position of spacecraft
    let angle = -Math.PI / 2; // Start directly above the Earth (90 degrees)
    let spacecraftX = r * Math.cos(angle);
    let spacecraftY = r * Math.sin(angle);

    // Velocity components
    let vx = -v * Math.sin(angle); // Velocity in the X direction (negative for counter-clockwise motion)
    let vy = v * Math.cos(angle);  // Velocity in the Y direction (positive for upward motion)

    // Time step for the numerical integration
    const dt = 1; // seconds

    // Initialize elapsed simulation time
    let elapsedTime = 0; // Time in seconds

    // Flags to check if impulses are applied
    let impulse1Applied = false;

    // Time when the impulses are applied
    let impulse1Time = 0;

    // Function to convert elapsed time to days:hours
    function formatTime(seconds) {
        let days = Math.floor(seconds / (3600 * 24));  // Calculate total days
        let hours = Math.floor((seconds % (3600 * 24)) / 3600);  // Calculate remaining hours
        return days + ' days ' + hours + ' hours';  // Return days and hours only
    }

    // Update function for numerical integration
    function updateOrbit() {
        // Apply first impulsive velocity change when the user presses the button
        if (!impulse1Applied && impulse1Time > 0) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV * unitVectorX;
            vy += deltaV * unitVectorY;

            impulse1Applied = true;
            impulse1Time = elapsedTime;
        }

        // Calculate distance to Earth and the Moon
        let r_earth = Math.sqrt(spacecraftX * spacecraftX + spacecraftY * spacecraftY); // Distance from spacecraft to Earth
        let r_moon = Math.sqrt(Math.pow(spacecraftX - MOON_DISTANCE, 2) + Math.pow(spacecraftY, 2)); // Distance from spacecraft to Moon

        // Calculate accelerations due to Earth and Moon
        let acceleration_earth = -G * Me / (r_earth * r_earth);
        let acceleration_moon = -G * Mm / (r_moon * r_moon);

        // Gravitational acceleration components from Earth and Moon
        ax_earth = acceleration_earth * (spacecraftX / r_earth);
        ay_earth = acceleration_earth * (spacecraftY / r_earth);

        ax_moon = acceleration_moon * ((spacecraftX - MOON_DISTANCE) / r_moon);
        ay_moon = acceleration_moon * (spacecraftY / r_moon);

        // Total acceleration: sum of Earth and Moon's effects
        let ax = ax_earth + ax_moon;
        let ay = ay_earth + ay_moon;

        console.log('r_craft',spacecraftX);
        console.log('r_moon',MOON_DISTANCE);


        // Update the velocity with the acceleration
        vx += ax * dt;
        vy += ay * dt;

        // Update the spacecraft's position
        spacecraftX += vx * dt;
        spacecraftY += vy * dt;

        // Recalculate the distance to the Earth
        r = Math.sqrt(spacecraftX * spacecraftX + spacecraftY * spacecraftY);

        // Update the elapsed time
        elapsedTime += dt;

        // Redraw the scene
        drawScene();
    }


    // Function to draw the Earth, spacecraft, elapsed time, and the velocity arrow
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Convert distance to altitude in kilometers
        const altitudeInKm = (r - EARTH_RADIUS) / 1000;

        // Draw the Earth
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, 25, 0, 2 * Math.PI);
        ctx.fillStyle = 'blue';
        ctx.fill();

        // Draw the Moon (to the left of the Earth)
        ctx.beginPath();
        ctx.arc(canvas.width / 2 - MOON_DISTANCE, canvas.height / 2, 15, 0, 2 * Math.PI); // Moon size adjusted
        ctx.fillStyle = 'gray';
        ctx.fill();

        // Draw the spacecraft
        ctx.beginPath();
        ctx.arc(canvas.width / 2 + spacecraftX, canvas.height / 2 + spacecraftY, 8, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();

        // Display the elapsed simulation time (formatted as HH:MM:SS)
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        
        const timeText = 'Elapsed Time: ' + formatTime(elapsedTime);
        const textWidth = ctx.measureText(timeText).width;

        ctx.fillText(timeText, (canvas.width - textWidth) / 2, 40);

        // Display the altitude (distance above Earth's surface in km) centered at the top
        const altitudeText = 'Altitude: ' + altitudeInKm.toFixed(2) + ' km';
        const altitudeTextWidth = ctx.measureText(altitudeText).width;
        ctx.fillText(altitudeText, (canvas.width - altitudeTextWidth) / 2, 70);

        let speed = Math.sqrt(vx * vx + vy * vy);

        // Draw the acceleration arrows from Earth and Moon
        drawArrow(
            canvas.width / 2 + spacecraftX,
            canvas.height / 2 + spacecraftY,
            ax_earth * 10,  // Scale the acceleration for visibility
            ay_earth * 10,  // Scale the acceleration for visibility
            'blue'  // Color for Earth's acceleration
            );

        drawArrow(
            canvas.width / 2 + spacecraftX,
            canvas.height / 2 + spacecraftY,
            ax_moon * 100,  // Scale the acceleration for visibility
            ay_moon * 100,  // Scale the acceleration for visibility
            'white'  // Color for Moon's acceleration
            );

        // Display "Impulse" text and arrow for the impulse
        if (impulse1Applied && elapsedTime - impulse1Time <= 1000) {
//            ctx.fillText('Impulse 1', canvas.width / 2 - 50, canvas.height / 2 + 5);
            drawArrow(
                canvas.width / 2 + spacecraftX,
                canvas.height / 2 + spacecraftY,
                deltaV*vx / speed / 10,
                deltaV*vy / speed / 10,
                'yellow'
            );
        }

        // Update the slider value display
        document.getElementById('sliderValue').textContent = 'deltaV: ' + deltaV + ' m/s';
    }

    // Function to draw an arrow
    function drawArrow(x, y, dx, dy, color = 'white') {
        const size = 10;
        const angle = Math.atan2(dy, dx);
        const arrowLength = 50 + 0.3*Math.sqrt(dx * dx + dy * dy);

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(arrowLength - size, 0);
        ctx.lineTo(arrowLength - size * 2, -size / 2);
        ctx.moveTo(arrowLength - size, 0);
        ctx.lineTo(arrowLength - size * 2, size / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }

    // Reset the simulation
    function resetSimulation() {
        // Reset the spacecraft's initial conditions
        r = EARTH_RADIUS + altitude; // Reset distance to the center of the Earth
        v = -Math.sqrt(G * Me / r); // Reset orbital velocity
        angle = -Math.PI / 2; // Reset angle (directly above the Earth)
        spacecraftX = r * Math.cos(angle); // Reset X position
        spacecraftY = r * Math.sin(angle); // Reset Y position

        // Reset velocity components
        vx = -v * Math.sin(angle); // Reset velocity in the X direction
        vy = v * Math.cos(angle);  // Reset velocity in the Y direction

        // Reset simulation time and elapsed time
        elapsedTime = 0;

        // Reset impulse flags and times
        impulse1Applied = false;
        impulse1Time = 0;

        // Reset deltaV slider
        deltaV = 10;
        document.getElementById('deltaV').value = deltaV;

        // Update the slider value display
        document.getElementById('sliderValue').textContent = 'deltaV: ' + deltaV + ' m/s';

        // Clear the canvas and redraw the initial scene
        drawScene();

    }

    // Attach event listener to the reset button
    document.getElementById('resetButton').addEventListener('click', resetSimulation);

    // Event listener for the apply impulse button
    document.getElementById('impulseButton').addEventListener('click', () => {
        impulse1Time = elapsedTime;
        impulse1Applied = false;
    });

    // Event listener for the deltaV slider to adjust the impulsive velocity change
    document.getElementById('deltaV').addEventListener('input', (event) => {
        deltaV = parseInt(event.target.value);
    });

    // Start the animation loop
    function animate() {
        updateOrbit();
        requestAnimationFrame(animate);
    }

    animate();
</script>
</body>
</html>
