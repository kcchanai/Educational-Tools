<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spacecraft Orbit Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="orbitCanvas"></canvas>

<script>
    const canvas = document.getElementById('orbitCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to fill the window
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Constants
    const G = 6.67430e-11; // Gravitational constant (m^3⋅kg^−1⋅s^−2)
    const Me = 5.972e24; // Mass of the Earth (kg)
    const Mm = 7.342e22 * 50; // Mass of the Moon (kg)
    const EARTH_RADIUS = 6371000; // Earth's radius in meters
    const MOON_RADIUS = 1737000; // Moon's radius in meters
    const MOON_DISTANCE = 384400000 * 0.2; // Average distance from Earth to Moon in meters

    const SCALE = 8E4; // Scale to make the animation visually manageable
    const MOON_SCALE = 2e5; // Scale for the Moon size
    
    const deltaV1 = 1500; // Impulsive change in velocity (m/s)
    const T1 = 11000; // Time when deltaV1 is applied
    const T1interval = 1000; // How long to display the indicator
    const deltaV2 = 100; // Impulsive change in velocity (m/s)
    const T2 = 1750000; // Time when deltaV2 is applied
    const T2interval = 1000; // How long to display the indicator
    const deltaV3 = -100; // Impulsive change in velocity for third impulse (m/s)
    const T3 = 1950000; // Time when deltaV3 is applied
    const T3interval = 1000; // How long to display the third impulse indicator

    // Initial conditions for the spacecraft (Low Earth Orbit)
    const altitude = 1000000; // meters
    let r = EARTH_RADIUS + altitude; // Initial distance from the center of the Earth (meters)
    
    // Calculate the initial tangential velocity for circular orbit at LEO
    let v = -Math.sqrt(G * Me / r); // Orbital velocity in m/s
    
    // Initial angle and position of spacecraft
    let angle = -Math.PI / 2; // Start directly above the Earth (90 degrees)
    let spacecraftX = r * Math.cos(angle);
    let spacecraftY = r * Math.sin(angle);

    // Velocity components
    let vx = -v * Math.sin(angle); // Velocity in the X direction (negative for counter-clockwise motion)
    let vy = v * Math.cos(angle);  // Velocity in the Y direction (positive for upward motion)

    // Time step for the numerical integration
    const dt = 20; // seconds

    // Initialize elapsed simulation time
    let elapsedTime = 0; // Time in seconds

    // Flags to check if impulses are applied
    let impulse1Applied = false;
    let impulse2Applied = false;
    let impulse3Applied = false;

    // Time when the impulses are applied
    let impulse1Time = 0;
    let impulse2Time = 0;
    let impulse3Time = 0;

    // Function to convert elapsed time to hours:minutes:seconds
    function formatTime(seconds) {
        let hours = Math.floor(seconds / 3600);
        let minutes = Math.floor((seconds % 3600) / 60);
        let secondsLeft = seconds % 60;

        return hours.toString().padStart(2, '0') + ':' +
               minutes.toString().padStart(2, '0') + ':' +
               secondsLeft.toFixed(0).padStart(2, '0');
    }

    // Update function for numerical integration
    function updateOrbit() {
        // Apply first impulsive velocity change at time T1 seconds (only once)
        if (elapsedTime >= T1 && elapsedTime < T1 + dt && !impulse1Applied) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV1 * unitVectorX;
            vy += deltaV1 * unitVectorY;

            impulse1Applied = true;
            impulse1Time = elapsedTime;
        }

        // Apply second impulsive velocity change at time T2 seconds (only once)
        if (elapsedTime >= T2 && elapsedTime < T2 + dt && !impulse2Applied) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV2 * unitVectorX;
            vy += deltaV2 * unitVectorY;

            impulse2Applied = true;
            impulse2Time = elapsedTime;
        }

        // Apply third impulsive velocity change at time T3 seconds (only once)
        if (elapsedTime >= T3 && elapsedTime < T3 + dt && !impulse3Applied) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV3 * unitVectorX;
            vy += deltaV3 * unitVectorY;

            impulse3Applied = true;
            impulse3Time = elapsedTime;
        }

        // Calculate the gravitational force of the Earth
        let earthForceX = -G * Me * (spacecraftX / Math.pow(r, 3));
        let earthForceY = -G * Me * (spacecraftY / Math.pow(r, 3));

        // Calculate the position of the Moon relative to the spacecraft
        const moonX = -MOON_DISTANCE;
        const moonY = 0;

        // Calculate the distance from the spacecraft to the Moon
        let moonDistance = Math.sqrt(Math.pow(spacecraftX - moonX, 2) + Math.pow(spacecraftY - moonY, 2));

        // Calculate the gravitational force of the Moon
        let moonForceX = -G * Mm * (spacecraftX - moonX) / Math.pow(moonDistance, 3);
        let moonForceY = -G * Mm * (spacecraftY - moonY) / Math.pow(moonDistance, 3);

        // Total gravitational acceleration (from both Earth and Moon)
        let ax = (earthForceX + moonForceX) * 1;
        let ay = (earthForceY + moonForceY) * 1;

        // Update velocity based on acceleration
        vx += ax * dt;
        vy += ay * dt;

        // Update position based on velocity
        spacecraftX += vx * dt;
        spacecraftY += vy * dt;

        // Update the distance (r) from the center of the Earth
        r = Math.sqrt(spacecraftX * spacecraftX + spacecraftY * spacecraftY);

        // Increment elapsed time
        elapsedTime += dt;

        // Call the drawScene function to update the canvas
        drawScene();
    }

    // Function to draw the Earth, spacecraft, elapsed time, and the velocity arrow
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Convert distance to altitude in kilometers
        const altitudeInKm = (r - EARTH_RADIUS) / 1000;

        // Calculate the center point between Earth and Moon
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // New Earth position (centered between Earth and Moon)
        const earthX = centerX + MOON_DISTANCE / SCALE / 2;
        const earthY = centerY;

        // Draw the Earth
        ctx.beginPath();
        ctx.arc(earthX, earthY, EARTH_RADIUS / SCALE * 0.20, 0, 2 * Math.PI);
        ctx.fillStyle = 'turquoise';
        ctx.fill();

        // Draw the Moon to the left of Earth
        const moonX = centerX - MOON_DISTANCE / SCALE / 2;
        const moonY = centerY;
        ctx.beginPath();
        ctx.arc(moonX, moonY, MOON_RADIUS / MOON_SCALE, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();

        // Draw the spacecraft relative to the new Earth center
        ctx.beginPath();
        ctx.arc(
            earthX + spacecraftX / SCALE,
            earthY + spacecraftY / SCALE,
            10,
            0,
            2 * Math.PI
        );
        ctx.fillStyle = 'red';
        ctx.fill();

        // Calculate the gravitational force vector of the Earth
        let gravityForceX = -G * Me * (spacecraftX / Math.pow(r, 3));
        let gravityForceY = -G * Me * (spacecraftY / Math.pow(r, 3));

        // Calculate the gravitational force vector of the Moon
        const moonXPosition = centerX - MOON_DISTANCE; // Moon's position
        const moonYPosition = centerY;
        let moonDistance = Math.sqrt(Math.pow(spacecraftX - moonXPosition, 2) + Math.pow(spacecraftY - moonYPosition, 2));
        let moonForceX = -G * Mm * (spacecraftX - moonXPosition) / Math.pow(moonDistance, 3);
        let moonForceY = -G * Mm * (spacecraftY - moonYPosition) / Math.pow(moonDistance, 3);

        // Scale down the forces for visual clarity
        const forceScale = 2e0; 

        // Draw the Earth's gravitational force vector
        drawArrow(
            earthX + spacecraftX / SCALE, 
            earthY + spacecraftY / SCALE, 
            gravityForceX * forceScale, 
            gravityForceY * forceScale, 
            'turquoise'
        );

        // Draw the Moon's gravitational force vector
        drawArrow(
            earthX + spacecraftX / SCALE, 
            earthY + spacecraftY / SCALE, 
            moonForceX * forceScale, 
            moonForceY * forceScale, 
            'white'  // Color for Moon's gravity vector
        );

        // Display the elapsed simulation time (formatted as HH:MM:SS)
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        
        const timeText = 'Elapsed Time: ' + formatTime(elapsedTime);
        const textWidth = ctx.measureText(timeText).width;

        ctx.fillText(timeText, (canvas.width - textWidth) / 2, 40);

        // Display the raw time in seconds (for debugging)
        const timeInSecondsText = 'Time (seconds): ' + elapsedTime.toFixed(0);
        const timeInSecondsTextWidth = ctx.measureText(timeInSecondsText).width;
        ctx.fillText(timeInSecondsText, (canvas.width - timeInSecondsTextWidth) / 2, 100);

        // Display the altitude (distance above Earth's surface in km) centered at the top
        const altitudeText = 'Altitude: ' + altitudeInKm.toFixed(2) + ' km';
        const altitudeTextWidth = ctx.measureText(altitudeText).width;
        ctx.fillText(altitudeText, (canvas.width - altitudeTextWidth) / 2, 70);

        let speed = Math.sqrt(vx * vx + vy * vy);
        
        // Display "Impulse" text and arrow for the first impulse
        if (impulse1Applied && elapsedTime - impulse1Time <= T1interval) {
            ctx.fillText('Impulse 1', canvas.width / 2 - 50, canvas.height / 2 + 5);
            drawArrow(
                earthX + spacecraftX / SCALE, 
                earthY + spacecraftY / SCALE, 
                deltaV1*vx / speed / 10,
                deltaV1*vy / speed / 10
            );
        }

        // Display "Impulse" text and arrow for the second impulse
        if (impulse2Applied && elapsedTime - impulse2Time <= T2interval) {
            ctx.fillText('Impulse 2', canvas.width / 2 - 50, canvas.height / 2 + 5);
            drawArrow(
                earthX + spacecraftX / SCALE, 
                earthY + spacecraftY / SCALE, 
                deltaV2*vx / speed / 10,
                deltaV2*vy / speed / 10
            );
        }

        // Display "Impulse" text and arrow for the third impulse
        if (impulse3Applied && elapsedTime - impulse3Time <= T3interval) {
            ctx.fillText('Impulse 3', canvas.width / 2 - 50, canvas.height / 2 + 5);
            drawArrow(
                earthX + spacecraftX / SCALE, 
                earthY + spacecraftY / SCALE, 
                deltaV3*vx / speed / 10,
                deltaV3*vy / speed / 10
            );
        }
    }
   

    // Function to draw an arrow with minimum length plus a scaled additional length and customizable color
    function drawArrow(x, y, dx, dy, color = 'yellow') {
        const baseLength = 15; // Minimum length for the arrow
        const scaleFactor = 4; // Scale factor for additional length

        // Calculate the dynamic length based on the input
        const additionalLength = Math.sqrt(dx * dx + dy * dy) * scaleFactor;
        const arrowLength = baseLength + additionalLength;

        const angle = Math.atan2(dy, dx);
        const arrowSize = 10; // Size for the arrowhead

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + arrowLength * Math.cos(angle), y + arrowLength * Math.sin(angle));
        ctx.strokeStyle = color; // Set arrow color to the input color
        ctx.lineWidth = 3;
        ctx.stroke();

        // Draw the arrowhead
        ctx.beginPath();
        ctx.moveTo(x + arrowLength * Math.cos(angle), y + arrowLength * Math.sin(angle));
        ctx.lineTo(
            x + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle - Math.PI / 6),
            y + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            x + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle + Math.PI / 6),
            y + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = color; // Set arrowhead color to the input color
        ctx.fill();
    }



    // Start the simulation
    function startSimulation() {
        updateOrbit();
        setInterval(updateOrbit, 1000 / 60); // 60 FPS
    }

    // Start the simulation after the page loads
    window.onload = startSimulation;
</script>
</body>
</html>
