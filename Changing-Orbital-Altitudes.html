<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spacecraft Orbit Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #deltaVSlider {
    position: fixed;
    bottom: 10px; /* Position 10px from the bottom */
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    color: white;
    }

    #sliderValue {
        position: fixed;
        bottom: 40px; /* Position below the slider */
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 16px;
    }

    #applyImpulseButton {
        position: fixed;
        bottom: 70px; /* Position below the slider value */
        left: 50%;
        transform: translateX(-50%);
        padding: 10px;
        background-color: #007BFF;
        color: white;
        border: none;
        cursor: pointer;
    }

    #applyImpulseButton:hover {
        background-color: #0056b3;
    }

    </style>
</head>
<body>
<canvas id="orbitCanvas"></canvas>

<!-- Slider to control deltaV -->
<div id="deltaVSlider">
    <label for="deltaV">deltaV: </label>
    <input type="range" id="deltaV" min="-1000" max="1000" value="10">
</div>

<div id="sliderValue">deltaV: 10 m/s</div>

<!-- Button to apply the impulse -->
<button id="applyImpulseButton">Apply Impulse</button>

<script>
    const canvas = document.getElementById('orbitCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to fill the window
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Constants
    const G = 6.67430e-11; // Gravitational constant (m^3⋅kg^−1⋅s^−2)
    const M = 5.972e24; // Mass of the Earth (kg)
    const EARTH_RADIUS = 6371000; // Earth's radius in meters
    const SCALE = 1E5; // Scale to make the animation visually manageable

    let deltaV = 10; // Impulsive change in velocity (m/s) - set initial value
    const deltaV2 = 1000; // Impulsive change in velocity (m/s)
    const deltaV3 = -1000; // Impulsive change in velocity for third impulse (m/s)

    // Initial conditions for the spacecraft (Low Earth Orbit)
    const altitude = 500000; // altitude (meters)
    let r = EARTH_RADIUS + altitude; // Initial distance from the center of the Earth (meters)
    
    // Calculate the initial tangential velocity for circular orbit at LEO
    let v = -Math.sqrt(G * M / r); // Orbital velocity in m/s
    
    // Initial angle and position of spacecraft
    let angle = -Math.PI / 2; // Start directly above the Earth (90 degrees)
    let spacecraftX = r * Math.cos(angle);
    let spacecraftY = r * Math.sin(angle);

    // Velocity components
    let vx = -v * Math.sin(angle); // Velocity in the X direction (negative for counter-clockwise motion)
    let vy = v * Math.cos(angle);  // Velocity in the Y direction (positive for upward motion)

    // Time step for the numerical integration
    const dt = 50; // seconds

    // Initialize elapsed simulation time
    let elapsedTime = 0; // Time in seconds

    // Flags to check if impulses are applied
    let impulse1Applied = false;
    let impulse2Applied = false;
    let impulse3Applied = false;

    // Time when the impulses are applied
    let impulse1Time = 0;
    let impulse2Time = 0;
    let impulse3Time = 0;

    // Function to convert elapsed time to hours:minutes:seconds
    function formatTime(seconds) {
        let hours = Math.floor(seconds / 3600);
        let minutes = Math.floor((seconds % 3600) / 60);
        let secondsLeft = seconds % 60;

        return hours.toString().padStart(2, '0') + ':' +
               minutes.toString().padStart(2, '0') + ':' +
               secondsLeft.toFixed(0).padStart(2, '0');
    }

    // Update function for numerical integration
    function updateOrbit() {
        // Apply first impulsive velocity change when the user presses the button
        if (!impulse1Applied && impulse1Time > 0) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV * unitVectorX;
            vy += deltaV * unitVectorY;

            impulse1Applied = true;
            impulse1Time = elapsedTime;
        }

        // Apply second impulsive velocity change (for testing)
        if (!impulse2Applied) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV2 * unitVectorX;
            vy += deltaV2 * unitVectorY;

            impulse2Applied = true;
            impulse2Time = elapsedTime;
        }

        // Apply third impulsive velocity change (for testing)
        if (!impulse3Applied) {
            let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
            let unitVectorX = vx / velocityMagnitude;
            let unitVectorY = vy / velocityMagnitude;

            vx += deltaV3 * unitVectorX;
            vy += deltaV3 * unitVectorY;

            impulse3Applied = true;
            impulse3Time = elapsedTime;
        }

        let acceleration = -G * M / (r * r); // Gravitational acceleration in m/s^2

        let ax = acceleration * (spacecraftX / r);
        let ay = acceleration * (spacecraftY / r);

        vx += ax * dt;
        vy += ay * dt;

        spacecraftX += vx * dt;
        spacecraftY += vy * dt;

        r = Math.sqrt(spacecraftX * spacecraftX + spacecraftY * spacecraftY);

        elapsedTime += dt;

        drawScene();
    }

    // Function to draw the Earth, spacecraft, elapsed time, and the velocity arrow
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Convert distance to altitude in kilometers
        const altitudeInKm = (r - EARTH_RADIUS) / 1000;

        // Draw the Earth
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, EARTH_RADIUS / SCALE*0.5, 0, 2 * Math.PI);
        ctx.fillStyle = 'blue';
        ctx.fill();

        // Draw the spacecraft
        ctx.beginPath();
        ctx.arc(canvas.width / 2 + spacecraftX / SCALE, canvas.height / 2 + spacecraftY / SCALE, 10, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();

        // Display the elapsed simulation time (formatted as HH:MM:SS)
        ctx.font = '24px Arial';
        ctx.fillStyle = 'white';
        
        const timeText = 'Elapsed Time: ' + formatTime(elapsedTime);
        const textWidth = ctx.measureText(timeText).width;

        ctx.fillText(timeText, (canvas.width - textWidth) / 2, 40);

        // Display the altitude (distance above Earth's surface in km) centered at the top
        const altitudeText = 'Altitude: ' + altitudeInKm.toFixed(2) + ' km';
        const altitudeTextWidth = ctx.measureText(altitudeText).width;
        ctx.fillText(altitudeText, (canvas.width - altitudeTextWidth) / 2, 70);

        let speed = Math.sqrt(vx * vx + vy * vy);

        // Display "Impulse" text and arrow for the first impulse
        if (impulse1Applied && elapsedTime - impulse1Time <= 1000) {
//            ctx.fillText('Impulse 1', canvas.width / 2 - 50, canvas.height / 2 + 5);
            drawArrow(
                canvas.width / 2 + spacecraftX / SCALE,
                canvas.height / 2 + spacecraftY / SCALE,
                deltaV*vx / speed / 10,
                deltaV*vy / speed / 10
            );
        }

        // Update the slider value display
        document.getElementById('sliderValue').textContent = 'deltaV: ' + deltaV + ' m/s';
    }

    // Function to draw an arrow
    function drawArrow(x, y, dx, dy) {
        const size = 10;
        const angle = Math.atan2(dy, dx);
        const arrowLength = 50 + 0.3*Math.sqrt(dx * dx + dy * dy);

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(arrowLength - size, 0);
        ctx.lineTo(arrowLength - size * 2, -size / 2);
        ctx.moveTo(arrowLength - size, 0);
        ctx.lineTo(arrowLength - size * 2, size / 2);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }

    // Event listener for the apply impulse button
    document.getElementById('applyImpulseButton').addEventListener('click', () => {
        impulse1Time = elapsedTime;
        impulse1Applied = false;
    });

    // Event listener for the deltaV slider to adjust the impulsive velocity change
    document.getElementById('deltaV').addEventListener('input', (event) => {
        deltaV = parseInt(event.target.value);
    });

    // Start the animation loop
    function animate() {
        updateOrbit();
        requestAnimationFrame(animate);
    }

    animate();
</script>
</body>
</html>
